# P0.1: Conditional Logic - Implementation Guide

> **Status**: ðŸ”´ Not Started  
> **Priority**: P0 (Critical Foundation)  
> **Effort**: 3-5 days  
> **Complexity**: Medium-High

---

## Overview

Enable workflows to branch based on runtime data, allowing decision trees instead of linear sequences.

**Current**: Step 1 â†’ Step 2 â†’ Step 3 â†’ Step 4 (linear only)  
**After**: Step 1 â†’ [Decision: If approved] â†’ Step 2A or Step 2B

---

## Implementation Checklist

### Phase 1: Database Schema (0.5 days)
- [ ] Update `prisma/schema.prisma`
- [ ] Create migration
- [ ] Test migration locally
- [ ] Update Prisma client

### Phase 2: Core Logic (1.5 days)
- [ ] Create condition evaluator engine
- [ ] Implement operators (==, !=, >, <, contains, etc.)
- [ ] Add workflow context field resolution
- [ ] Write unit tests for evaluator
- [ ] Update step execution to check conditions

### Phase 3: API Layer (0.5 days)
- [ ] Update step creation validation
- [ ] Update step update validation
- [ ] Add condition validation endpoint
- [ ] Update API documentation

### Phase 4: UI Components (1.5 days)
- [ ] Create condition builder component
- [ ] Add to step configuration form
- [ ] Create visual condition display
- [ ] Add to workflow timeline view
- [ ] Add to template preview

### Phase 5: Handler Updates (0.5 days)
- [ ] Update existing handlers to support conditions
- [ ] Add conditional execution examples
- [ ] Update handler documentation

### Phase 6: Testing & Documentation (0.5 days)
- [ ] Integration tests
- [ ] E2E tests for conditional workflows
- [ ] Update user documentation
- [ ] Create example workflows

---

## Technical Design

### 1. Schema Changes

```prisma
model WorkflowInstanceStep {
  // ... existing fields ...
  
  // NEW: Conditional execution
  conditionType    ConditionType?  @default(ALWAYS)
  conditionConfig  Json?           // Condition rules
  nextStepOnTrue   String?         // Step ID if condition true
  nextStepOnFalse  String?         // Step ID if condition false
  
  // Relations for next steps
  nextStepTrue     WorkflowInstanceStep? @relation("TrueNext", fields: [nextStepOnTrue], references: [id])
  nextStepFalse    WorkflowInstanceStep? @relation("FalseNext", fields: [nextStepOnFalse], references: [id])
  
  // Inverse relations
  prevStepTrue     WorkflowInstanceStep[] @relation("TrueNext")
  prevStepFalse    WorkflowInstanceStep[] @relation("FalseNext")
}

enum ConditionType {
  ALWAYS              // Default - always execute (no condition)
  IF_TRUE             // Execute only if condition is true
  IF_FALSE            // Execute only if condition is false
  SWITCH              // Multiple conditions (future enhancement)
}
```

### 2. Condition Configuration Schema

```typescript
// lib/workflows/conditions/types.ts
export type ConditionConfig = {
  type: "simple" | "compound";
  
  // Simple condition
  field: string;              // "workflow.context.approved"
  operator: ConditionOperator;
  value: unknown;             // Comparison value
  
  // Compound condition (future)
  logic?: "AND" | "OR";
  conditions?: ConditionConfig[];
};

export type ConditionOperator = 
  | "==" | "!=" | ">" | "<" | ">=" | "<="
  | "contains" | "startsWith" | "endsWith"
  | "in" | "notIn"
  | "exists" | "notExists"
  | "isEmpty" | "isNotEmpty";
```

### 3. Condition Evaluator Engine

```typescript
// lib/workflows/conditions/evaluator.ts
import type { WorkflowRuntimeContext } from "../types";
import type { ConditionConfig } from "./types";

export class ConditionEvaluator {
  /**
   * Evaluate a condition against workflow context
   */
  static evaluate(
    condition: ConditionConfig,
    context: WorkflowRuntimeContext
  ): boolean {
    if (condition.type === "simple") {
      return this.evaluateSimple(condition, context);
    }
    
    if (condition.type === "compound") {
      return this.evaluateCompound(condition, context);
    }
    
    throw new Error(`Unknown condition type: ${condition.type}`);
  }
  
  /**
   * Evaluate simple condition
   */
  private static evaluateSimple(
    condition: ConditionConfig,
    context: WorkflowRuntimeContext
  ): boolean {
    const fieldValue = this.resolveField(condition.field, context);
    const compareValue = condition.value;
    
    switch (condition.operator) {
      case "==":
        return fieldValue === compareValue;
      case "!=":
        return fieldValue !== compareValue;
      case ">":
        return (fieldValue as number) > (compareValue as number);
      case "<":
        return (fieldValue as number) < (compareValue as number);
      case ">=":
        return (fieldValue as number) >= (compareValue as number);
      case "<=":
        return (fieldValue as number) <= (compareValue as number);
      case "contains":
        return String(fieldValue).includes(String(compareValue));
      case "startsWith":
        return String(fieldValue).startsWith(String(compareValue));
      case "endsWith":
        return String(fieldValue).endsWith(String(compareValue));
      case "in":
        return Array.isArray(compareValue) && compareValue.includes(fieldValue);
      case "notIn":
        return Array.isArray(compareValue) && !compareValue.includes(fieldValue);
      case "exists":
        return fieldValue !== undefined && fieldValue !== null;
      case "notExists":
        return fieldValue === undefined || fieldValue === null;
      case "isEmpty":
        return !fieldValue || (Array.isArray(fieldValue) && fieldValue.length === 0);
      case "isNotEmpty":
        return !!fieldValue && !(Array.isArray(fieldValue) && fieldValue.length === 0);
      default:
        throw new Error(`Unknown operator: ${condition.operator}`);
    }
  }
  
  /**
   * Resolve field path from context
   * Supports: "workflow.context.approved", "step.data.amount", "matter.status"
   */
  private static resolveField(
    fieldPath: string,
    context: WorkflowRuntimeContext
  ): unknown {
    const parts = fieldPath.split(".");
    let value: any = context;
    
    for (const part of parts) {
      if (value === undefined || value === null) {
        return undefined;
      }
      value = value[part];
    }
    
    return value;
  }
  
  /**
   * Evaluate compound condition (future)
   */
  private static evaluateCompound(
    condition: ConditionConfig,
    context: WorkflowRuntimeContext
  ): boolean {
    if (!condition.conditions || condition.conditions.length === 0) {
      return true;
    }
    
    const results = condition.conditions.map(c => this.evaluate(c, context));
    
    if (condition.logic === "AND") {
      return results.every(r => r);
    }
    
    if (condition.logic === "OR") {
      return results.some(r => r);
    }
    
    throw new Error(`Unknown logic: ${condition.logic}`);
  }
}
```

### 4. Step Execution Update

```typescript
// lib/workflows/runtime.ts (existing file, add to executeStep)

export async function executeStep(
  instanceId: string,
  stepId: string,
  action: "start" | "complete" | "fail",
  payload?: unknown
): Promise<WorkflowInstanceStep> {
  // ... existing code ...
  
  // NEW: After completing a step, determine next steps
  if (action === "complete" && step.actionState === ActionState.COMPLETED) {
    await determineNextSteps(step, context);
  }
  
  return step;
}

/**
 * Determine which steps should become READY based on conditions
 */
async function determineNextSteps(
  completedStep: WorkflowInstanceStep,
  context: WorkflowRuntimeContext
): Promise<void> {
  // Get all steps that depend on this step
  const dependentSteps = await prisma.workflowInstanceStep.findMany({
    where: {
      instanceId: completedStep.instanceId,
      OR: [
        { order: completedStep.order + 1 }, // Next in sequence
        // Add relations when implemented
      ]
    },
    include: {
      templateStep: true
    }
  });
  
  for (const step of dependentSteps) {
    // Check if step has condition
    if (step.conditionType === ConditionType.ALWAYS) {
      // No condition, just check dependencies
      await markStepReadyIfDependenciesMet(step);
      continue;
    }
    
    // Evaluate condition
    const conditionConfig = step.conditionConfig as ConditionConfig;
    const conditionMet = ConditionEvaluator.evaluate(conditionConfig, context);
    
    // Handle IF_TRUE / IF_FALSE
    if (step.conditionType === ConditionType.IF_TRUE && conditionMet) {
      await markStepReadyIfDependenciesMet(step);
    } else if (step.conditionType === ConditionType.IF_FALSE && !conditionMet) {
      await markStepReadyIfDependenciesMet(step);
    } else {
      // Condition not met, skip this step
      await prisma.workflowInstanceStep.update({
        where: { id: step.id },
        data: { actionState: ActionState.SKIPPED }
      });
    }
  }
}
```

### 5. UI Component - Condition Builder

```typescript
// components/workflows/ConditionBuilder.tsx
"use client";

import { useState } from "react";
import type { ConditionConfig } from "@/lib/workflows/conditions/types";

interface ConditionBuilderProps {
  value: ConditionConfig | null;
  onChange: (condition: ConditionConfig | null) => void;
  availableFields: { label: string; value: string }[];
}

export function ConditionBuilder({ value, onChange, availableFields }: ConditionBuilderProps) {
  const [enabled, setEnabled] = useState(!!value);
  
  return (
    <div className="space-y-4 border rounded-lg p-4">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium">
          Conditional Execution
        </label>
        <input
          type="checkbox"
          checked={enabled}
          onChange={(e) => {
            setEnabled(e.target.checked);
            if (!e.target.checked) {
              onChange(null);
            } else {
              onChange({
                type: "simple",
                field: "workflow.context.approved",
                operator: "==",
                value: true
              });
            }
          }}
          className="rounded"
        />
      </div>
      
      {enabled && value && (
        <div className="space-y-3">
          {/* Field selector */}
          <div>
            <label className="text-xs text-slate-600">Field</label>
            <select
              value={value.field}
              onChange={(e) => onChange({ ...value, field: e.target.value })}
              className="w-full rounded border p-2 text-sm"
            >
              {availableFields.map(f => (
                <option key={f.value} value={f.value}>{f.label}</option>
              ))}
            </select>
          </div>
          
          {/* Operator selector */}
          <div>
            <label className="text-xs text-slate-600">Operator</label>
            <select
              value={value.operator}
              onChange={(e) => onChange({ ...value, operator: e.target.value as any })}
              className="w-full rounded border p-2 text-sm"
            >
              <option value="==">Equals (==)</option>
              <option value="!=">Not Equals (!=)</option>
              <option value=">">Greater Than (&gt;)</option>
              <option value="<">Less Than (&lt;)</option>
              <option value=">=">Greater or Equal (&gt;=)</option>
              <option value="<=">Less or Equal (&lt;=)</option>
              <option value="contains">Contains</option>
              <option value="startsWith">Starts With</option>
              <option value="endsWith">Ends With</option>
              <option value="in">In List</option>
              <option value="exists">Exists</option>
              <option value="isEmpty">Is Empty</option>
            </select>
          </div>
          
          {/* Value input */}
          {!["exists", "notExists", "isEmpty", "isNotEmpty"].includes(value.operator) && (
            <div>
              <label className="text-xs text-slate-600">Value</label>
              <input
                type="text"
                value={String(value.value ?? "")}
                onChange={(e) => {
                  // Try to parse as number or boolean
                  let val: any = e.target.value;
                  if (val === "true") val = true;
                  else if (val === "false") val = false;
                  else if (!isNaN(Number(val))) val = Number(val);
                  onChange({ ...value, value: val });
                }}
                className="w-full rounded border p-2 text-sm"
                placeholder="Comparison value"
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

---

## Example Use Cases

### Example 1: Approval Branch
```typescript
// Step 2: Lawyer Approval
{
  id: "step-2",
  title: "Lawyer Approval",
  actionType: "APPROVAL",
  order: 2
}

// Step 3A: Send to Client (if approved)
{
  id: "step-3a",
  title: "Send Contract to Client",
  actionType: "SEND_EMAIL",
  order: 3,
  conditionType: "IF_TRUE",
  conditionConfig: {
    type: "simple",
    field: "workflow.context.approved",
    operator: "==",
    value: true
  }
}

// Step 3B: Request Revision (if rejected)
{
  id: "step-3b",
  title: "Request Revision",
  actionType: "TASK",
  order: 3,
  conditionType: "IF_FALSE",
  conditionConfig: {
    type: "simple",
    field: "workflow.context.approved",
    operator: "==",
    value: true
  }
}
```

### Example 2: Amount-Based Branch
```typescript
// Step 4: Check Payment Amount
{
  id: "step-4",
  title: "Check Payment Amount",
  conditionType: "IF_TRUE",
  conditionConfig: {
    type: "simple",
    field: "workflow.context.amount",
    operator: ">",
    value: 10000
  }
}

// If amount > 10000, requires senior approval
```

---

## Testing Strategy

### Unit Tests
```typescript
// lib/workflows/conditions/__tests__/evaluator.test.ts
describe("ConditionEvaluator", () => {
  it("should evaluate equality", () => {
    const condition = {
      type: "simple",
      field: "context.approved",
      operator: "==",
      value: true
    };
    const context = { context: { approved: true } };
    expect(ConditionEvaluator.evaluate(condition, context)).toBe(true);
  });
  
  // Add tests for all operators
});
```

### Integration Tests
```typescript
// Test workflow execution with conditions
describe("Conditional Workflow Execution", () => {
  it("should follow true branch when condition met", async () => {
    // Create workflow with conditional steps
    // Execute and verify correct path taken
  });
  
  it("should follow false branch when condition not met", async () => {
    // Create workflow with conditional steps
    // Execute and verify correct path taken
  });
});
```

---

## Migration Guide

### For Existing Workflows
1. Default all steps to `conditionType: ALWAYS`
2. No changes to behavior
3. Backward compatible

### Migration Script
```typescript
// scripts/migrate-conditional-logic.ts
async function migrate() {
  await prisma.workflowInstanceStep.updateMany({
    where: { conditionType: null },
    data: { conditionType: ConditionType.ALWAYS }
  });
}
```

---

## Documentation Updates

- [ ] Update API documentation with condition examples
- [ ] Update user guide with conditional workflow creation
- [ ] Add condition builder to UI screenshots
- [ ] Create video tutorial for conditional workflows
- [ ] Update copilot instructions with conditional logic patterns

---

## Rollout Plan

### Week 1: Core Implementation
- Day 1-2: Schema + evaluator
- Day 3-4: Runtime integration
- Day 5: Testing

### Week 2: UI & Polish
- Day 1-2: Condition builder component
- Day 3: Integration with workflow forms
- Day 4: Documentation
- Day 5: User acceptance testing

---

## Success Criteria

âœ… **Must Have**:
- Workflows can branch based on simple conditions
- UI allows creating conditional steps
- Existing workflows continue working unchanged
- Full test coverage (>80%)

ðŸŽ¯ **Should Have**:
- Visual indication of conditions in timeline
- Preview mode shows possible paths
- Error messages guide users on invalid conditions

ðŸ’¡ **Nice to Have**:
- Compound conditions (AND/OR)
- Condition validation in real-time
- Workflow path visualization

---

**Ready to Start?** Begin with Phase 1 (Database Schema)!
