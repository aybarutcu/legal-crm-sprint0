# P0.2 Flexible Step Dependencies - Implementation Plan

**Feature**: P0.2 - Flexible Step Dependencies  
**Status**: ðŸŸ¡ **IN PROGRESS**  
**Start Date**: October 19, 2025  
**Estimated Duration**: 2-3 days  
**Dependencies**: P0.1 âœ… Complete

---

## Executive Summary

Replace simple order-based step execution with flexible dependency management. This enables parallel workflows, complex dependencies (ALL/ANY logic), and non-linear workflow graphs.

**Current State**: Steps execute in strict sequential order (1 â†’ 2 â†’ 3 â†’ 4)  
**New State**: Steps can depend on multiple predecessors with AND/OR logic

---

## Table of Contents

1. [Phase 1: Schema & Database](#phase-1-schema--database)
2. [Phase 2: Dependency Resolution Logic](#phase-2-dependency-resolution-logic)
3. [Phase 3: Runtime Integration](#phase-3-runtime-integration)
4. [Phase 4: API & Validation](#phase-4-api--validation)
5. [Phase 5: UI Components](#phase-5-ui-components)
6. [Phase 6: Testing & Documentation](#phase-6-testing--documentation)

---

## Phase 1: Schema & Database

### Goal
Add dependency fields to schema and apply migration.

### Tasks

#### 1.1 Update Prisma Schema
**File**: `prisma/schema.prisma`

**Changes to `WorkflowTemplateStep`**:
```prisma
model WorkflowTemplateStep {
  id           String     @id @default(cuid())
  templateId   String
  order        Int
  title        String
  actionType   ActionType
  actionConfig Json
  roleScope    RoleScope
  required     Boolean    @default(true)
  
  // Conditional execution (P0.1)
  conditionType    ConditionType? @default(ALWAYS)
  conditionConfig  Json?
  nextStepOnTrue   Int?
  nextStepOnFalse  Int?
  
  // NEW: Flexible dependencies (P0.2)
  dependsOn        Int[]  @default([])  // Array of step orders (not IDs)
  dependencyLogic  DependencyLogic @default(ALL)
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  template      WorkflowTemplate       @relation(fields: [templateId], references: [id], onDelete: Cascade)
  instanceSteps WorkflowInstanceStep[]

  @@unique([templateId, order])
}
```

**Changes to `WorkflowInstanceStep`**:
```prisma
model WorkflowInstanceStep {
  id             String        @id @default(cuid())
  instanceId     String
  templateStepId String?
  order          Int
  title          String
  actionType     ActionType
  roleScope      RoleScope
  required       Boolean       @default(true)
  actionState    ActionState   @default(PENDING)
  actionData     Json?
  assignedToId   String?
  dueDate        DateTime?
  priority       TaskPriority? @default(MEDIUM)
  notes          String?
  startedAt      DateTime?
  completedAt    DateTime?
  
  // Conditional execution (P0.1)
  conditionType    ConditionType? @default(ALWAYS)
  conditionConfig  Json?
  nextStepOnTrue   Int?
  nextStepOnFalse  Int?
  
  // NEW: Flexible dependencies (P0.2)
  dependsOn        String[]  @default([])  // Array of step IDs
  dependencyLogic  DependencyLogic @default(ALL)
  
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  instance     WorkflowInstance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  templateStep WorkflowTemplateStep? @relation(fields: [templateStepId], references: [id], onDelete: SetNull)
  assignedTo   User?                 @relation("UserAssignedWorkflowSteps", fields: [assignedToId], references: [id], onDelete: SetNull)

  @@unique([instanceId, order])
  @@index([instanceId, actionState])
  @@index([assignedToId])
  @@index([dueDate])
}
```

**New Enum**:
```prisma
enum DependencyLogic {
  ALL     // All dependencies must complete (AND logic)
  ANY     // At least one dependency must complete (OR logic)
  CUSTOM  // Custom expression (future - not implemented in P0.2)
}
```

#### 1.2 Create Migration
**Command**:
```bash
npx prisma migrate dev --name add_flexible_dependencies
```

#### 1.3 Regenerate Prisma Client
**Command**:
```bash
npx prisma generate
```

**Deliverables**:
- [x] Updated schema with dependency fields
- [x] Migration created and applied
- [x] Prisma client regenerated
- [x] `DependencyLogic` enum added

**Time Estimate**: 1-2 hours

---

## Phase 2: Dependency Resolution Logic

### Goal
Create logic to determine when steps are ready based on dependencies.

### Tasks

#### 2.1 Create Dependency Resolver
**File**: `lib/workflows/dependency-resolver.ts` (NEW)

**Functions**:
1. `isDependencySatisfied()` - Check if a step's dependencies are met
2. `getDependencyGraph()` - Build graph of all dependencies
3. `detectCycles()` - Validate no circular dependencies
4. `getReadySteps()` - Get all steps that can be executed now
5. `getBlockedSteps()` - Get steps waiting on dependencies

**Implementation**:
```typescript
import type { WorkflowInstanceStep, DependencyLogic, ActionState } from "@prisma/client";

/**
 * Check if a step's dependencies are satisfied
 */
export function isDependencySatisfied(
  step: WorkflowInstanceStep,
  allSteps: WorkflowInstanceStep[]
): boolean {
  // No dependencies = always satisfied
  if (!step.dependsOn || step.dependsOn.length === 0) {
    return true;
  }

  const dependencySteps = allSteps.filter((s) => step.dependsOn.includes(s.id));

  // Check if dependencies exist
  if (dependencySteps.length !== step.dependsOn.length) {
    throw new Error(`Step ${step.id} has invalid dependencies`);
  }

  const completedDeps = dependencySteps.filter((s) => s.actionState === "COMPLETED");

  // ALL logic: All dependencies must be complete
  if (step.dependencyLogic === "ALL") {
    return completedDeps.length === dependencySteps.length;
  }

  // ANY logic: At least one dependency must be complete
  if (step.dependencyLogic === "ANY") {
    return completedDeps.length > 0;
  }

  // CUSTOM logic: Not implemented yet
  throw new Error(`Dependency logic ${step.dependencyLogic} not implemented`);
}

/**
 * Build dependency graph for visualization/validation
 */
export function getDependencyGraph(
  steps: WorkflowInstanceStep[]
): Map<string, string[]> {
  const graph = new Map<string, string[]>();

  for (const step of steps) {
    graph.set(step.id, step.dependsOn || []);
  }

  return graph;
}

/**
 * Detect circular dependencies using DFS
 */
export function detectCycles(steps: WorkflowInstanceStep[]): string[] {
  const graph = getDependencyGraph(steps);
  const visited = new Set<string>();
  const recursionStack = new Set<string>();
  const cycles: string[] = [];

  function dfs(nodeId: string, path: string[]): void {
    if (recursionStack.has(nodeId)) {
      cycles.push([...path, nodeId].join(" â†’ "));
      return;
    }

    if (visited.has(nodeId)) {
      return;
    }

    visited.add(nodeId);
    recursionStack.add(nodeId);

    const dependencies = graph.get(nodeId) || [];
    for (const depId of dependencies) {
      dfs(depId, [...path, nodeId]);
    }

    recursionStack.delete(nodeId);
  }

  for (const step of steps) {
    if (!visited.has(step.id)) {
      dfs(step.id, []);
    }
  }

  return cycles;
}

/**
 * Get all steps that are ready to execute (dependencies satisfied)
 */
export function getReadySteps(
  steps: WorkflowInstanceStep[]
): WorkflowInstanceStep[] {
  return steps.filter((step) => {
    // Skip completed or failed steps
    if (["COMPLETED", "FAILED", "SKIPPED"].includes(step.actionState)) {
      return false;
    }

    // Check if dependencies are satisfied
    return isDependencySatisfied(step, steps);
  });
}

/**
 * Get steps blocked by unsatisfied dependencies
 */
export function getBlockedSteps(
  steps: WorkflowInstanceStep[]
): WorkflowInstanceStep[] {
  return steps.filter((step) => {
    // Only consider pending steps
    if (step.actionState !== "PENDING") {
      return false;
    }

    // Check if blocked by dependencies
    return !isDependencySatisfied(step, steps);
  });
}

/**
 * Get dependency status for a step
 */
export interface DependencyStatus {
  stepId: string;
  isSatisfied: boolean;
  dependencyCount: number;
  completedCount: number;
  pendingDependencies: string[];
  logic: DependencyLogic;
}

export function getDependencyStatus(
  step: WorkflowInstanceStep,
  allSteps: WorkflowInstanceStep[]
): DependencyStatus {
  const dependencySteps = allSteps.filter((s) => step.dependsOn.includes(s.id));
  const completedDeps = dependencySteps.filter((s) => s.actionState === "COMPLETED");
  const pendingDeps = dependencySteps.filter((s) => s.actionState !== "COMPLETED");

  return {
    stepId: step.id,
    isSatisfied: isDependencySatisfied(step, allSteps),
    dependencyCount: dependencySteps.length,
    completedCount: completedDeps.length,
    pendingDependencies: pendingDeps.map((s) => s.id),
    logic: step.dependencyLogic,
  };
}
```

#### 2.2 Unit Tests
**File**: `tests/unit/workflows/dependency-resolver.spec.ts` (NEW)

**Test Cases**:
1. Step with no dependencies is always satisfied âœ“
2. ALL logic: satisfied when all dependencies complete âœ“
3. ALL logic: not satisfied if any dependency pending âœ“
4. ANY logic: satisfied when at least one dependency complete âœ“
5. ANY logic: not satisfied when all dependencies pending âœ“
6. Detect simple circular dependency (A â†’ B â†’ A) âœ“
7. Detect complex circular dependency (A â†’ B â†’ C â†’ A) âœ“
8. No cycles detected in valid graph âœ“
9. getReadySteps returns only steps with satisfied dependencies âœ“
10. getBlockedSteps returns only pending steps with unsatisfied deps âœ“

**Target**: 10+ passing tests

**Deliverables**:
- [x] Dependency resolver module
- [x] Cycle detection algorithm
- [x] Ready/blocked step calculation
- [x] Unit tests (10+ passing)

**Time Estimate**: 3-4 hours

---

## Phase 3: Runtime Integration

### Goal
Integrate dependency checking into workflow runtime.

### Tasks

#### 3.1 Update WorkflowRuntimeService
**File**: `lib/workflows/runtime.ts`

**Changes**:
1. Import dependency resolver functions
2. Update `getReadySteps()` to check dependencies (not just order)
3. Update `canStartStep()` to validate dependencies
4. Add `updateStepStates()` to recalculate states after completion
5. Add dependency validation when starting workflow

**Key Modifications**:
```typescript
import {
  isDependencySatisfied,
  detectCycles,
  getReadySteps as getDependencyReadySteps,
} from "./dependency-resolver";

// Update determineNextSteps to consider dependencies
export function determineNextSteps(/* ... */): number[] {
  // ... existing conditional logic ...
  
  // NEW: Filter by dependency satisfaction
  const readySteps = getDependencyReadySteps(instance.steps);
  const readyOrders = readySteps.map((s) => s.order);
  
  return candidateOrders.filter((order) => readyOrders.includes(order));
}

// Add dependency validation
export function validateWorkflowDependencies(
  steps: WorkflowInstanceStep[]
): { valid: boolean; errors: string[] } {
  const cycles = detectCycles(steps);
  
  if (cycles.length > 0) {
    return {
      valid: false,
      errors: cycles.map((cycle) => `Circular dependency detected: ${cycle}`),
    };
  }
  
  return { valid: true, errors: [] };
}
```

#### 3.2 Update Instance Creation
**File**: `app/api/workflows/instances/route.ts`

**Changes**:
- Copy `dependsOn` and `dependencyLogic` from template steps to instance steps
- Validate dependencies on creation
- Return validation errors if cycles detected

#### 3.3 Update Step State Transitions
**Files**: 
- `app/api/workflows/instances/[id]/steps/[stepId]/complete/route.ts`
- `app/api/workflows/instances/[id]/steps/[stepId]/start/route.ts`

**Changes**:
- After completing a step, recalculate states for dependent steps
- Move dependent steps from PENDING â†’ READY if dependencies satisfied
- Validate dependencies before allowing step to start

#### 3.4 Unit Tests
**File**: `tests/unit/workflows/workflow-runtime-dependencies.spec.ts` (NEW)

**Test Cases**:
1. Step transitions to READY when all dependencies complete âœ“
2. Step remains PENDING when dependencies incomplete âœ“
3. Multiple steps become READY simultaneously âœ“
4. ANY logic: step becomes READY when first dependency completes âœ“
5. Workflow creation fails with circular dependencies âœ“
6. Step cannot start if dependencies not satisfied âœ“

**Target**: 6+ passing tests

**Deliverables**:
- [x] Runtime integration of dependency checking
- [x] State recalculation after step completion
- [x] Dependency validation on workflow creation
- [x] Unit tests (6+ passing)

**Time Estimate**: 3-4 hours

---

## Phase 4: API & Validation

### Goal
Add API validation and update endpoints.

### Tasks

#### 4.1 Update Zod Schemas
**File**: `lib/validation/workflow.ts`

**Changes**:
```typescript
import { z } from "zod";

// Add DependencyLogic enum
export const dependencyLogicSchema = z.enum(["ALL", "ANY", "CUSTOM"]);

// Update template step schema
export const templateStepInputSchema = z.object({
  // ... existing fields ...
  
  // NEW: Dependency fields
  dependsOn: z.array(z.number()).default([]),
  dependencyLogic: dependencyLogicSchema.default("ALL"),
});

// Update instance step schema
export const instanceStepInputSchema = z.object({
  // ... existing fields ...
  
  // NEW: Dependency fields
  dependsOn: z.array(z.string()).default([]),
  dependencyLogic: dependencyLogicSchema.default("ALL"),
});
```

#### 4.2 Add Validation Endpoint
**File**: `app/api/workflows/validate-dependencies/route.ts` (NEW)

**Purpose**: Validate dependency configuration before saving

**Endpoint**: `POST /api/workflows/validate-dependencies`

**Request**:
```typescript
{
  steps: [
    { id: "1", dependsOn: [] },
    { id: "2", dependsOn: ["1"] },
    { id: "3", dependsOn: ["1", "2"], dependencyLogic: "ALL" }
  ]
}
```

**Response** (success):
```typescript
{
  valid: true,
  readySteps: ["1"],
  graph: { "1": [], "2": ["1"], "3": ["1", "2"] }
}
```

**Response** (error):
```typescript
{
  valid: false,
  errors: ["Circular dependency detected: 1 â†’ 2 â†’ 1"]
}
```

#### 4.3 Update Template Creation/Update APIs
**Files**:
- `app/api/workflows/templates/route.ts`
- `app/api/workflows/templates/[id]/route.ts`

**Changes**:
- Validate `dependsOn` and `dependencyLogic` fields
- Check for cycles before saving
- Return validation errors

#### 4.4 API Tests
**File**: `tests/api/workflows/dependencies.spec.ts` (NEW)

**Test Cases**:
1. Create template with valid dependencies âœ“
2. Reject template with circular dependencies âœ“
3. Create template with ALL dependency logic âœ“
4. Create template with ANY dependency logic âœ“
5. Validate dependencies via API endpoint âœ“

**Target**: 5+ passing tests

**Deliverables**:
- [x] Updated Zod schemas
- [x] Dependency validation endpoint
- [x] Template API updates
- [x] API tests (5+ passing)

**Time Estimate**: 2-3 hours

---

## Phase 5: UI Components

### Goal
Add UI for configuring and visualizing dependencies.

### Tasks

#### 5.1 Create DependencySelector Component
**File**: `components/workflows/dependencies/DependencySelector.tsx` (NEW)

**Purpose**: Select which steps this step depends on

**Props**:
```typescript
interface DependencySelectorProps {
  stepOrder: number;                    // Current step's order
  availableSteps: { order: number; title: string }[];  // Steps that can be dependencies
  dependsOn: number[];                  // Currently selected dependencies
  dependencyLogic: DependencyLogic;     // ALL or ANY
  onChange: (dependsOn: number[], logic: DependencyLogic) => void;
}
```

**UI**:
- Multi-select dropdown for available steps
- Radio buttons for ALL/ANY logic
- Visual indicator of selected dependencies
- Warning if no dependencies selected but logic is set

#### 5.2 Create DependencyVisualization Component
**File**: `components/workflows/dependencies/DependencyVisualization.tsx` (NEW)

**Purpose**: Visual graph of step dependencies

**Props**:
```typescript
interface DependencyVisualizationProps {
  steps: Array<{
    order: number;
    title: string;
    dependsOn: number[];
    dependencyLogic: DependencyLogic;
  }>;
}
```

**UI**:
- Simple node-and-edge diagram
- Nodes: steps (with order and title)
- Edges: dependency arrows
- Color coding: ALL (blue), ANY (orange)
- Cycle detection: red highlighting

#### 5.3 Create DependencyBadge Component
**File**: `components/workflows/dependencies/DependencyBadge.tsx` (NEW)

**Purpose**: Display dependency info compactly

**Props**:
```typescript
interface DependencyBadgeProps {
  dependsOn: number[];
  dependencyLogic: DependencyLogic;
  compact?: boolean;
}
```

**UI**:
- Small badge showing dependency count
- Tooltip with full details
- Color: Blue (ALL), Orange (ANY)
- Example: "Depends on 2 steps (ALL)"

#### 5.4 Integrate into Template Editor
**File**: `app/(dashboard)/workflows/templates/_components/client.tsx`

**Changes**:
1. Add DependencySelector to each step card
2. Show dependency count badge
3. Add "View Dependencies" button to show graph
4. Validate dependencies before saving

**UI Location**: After condition builder section

```tsx
{/* Dependency Configuration */}
<div className="space-y-3">
  <h5 className="text-sm font-semibold text-slate-700">
    Step Dependencies
  </h5>
  <DependencySelector
    stepOrder={step.order}
    availableSteps={draft.steps
      .filter((s) => s.order < step.order)
      .map((s) => ({ order: s.order, title: s.title }))}
    dependsOn={step.dependsOn || []}
    dependencyLogic={step.dependencyLogic || "ALL"}
    onChange={(dependsOn, logic) => {
      updateStep(index, { dependsOn, dependencyLogic: logic });
    }}
  />
</div>
```

#### 5.5 Update Instance Step Display
**File**: `components/workflows/InstanceStepCard.tsx`

**Changes**:
- Show dependency status (satisfied/waiting)
- Display which steps are blocking this step
- Show "X of Y dependencies complete"

**Deliverables**:
- [x] DependencySelector component
- [x] DependencyVisualization component
- [x] DependencyBadge component
- [x] Template editor integration
- [x] Instance step display updates

**Time Estimate**: 4-5 hours

---

## Phase 6: Testing & Documentation

### Goal
Comprehensive testing and user documentation.

### Tasks

#### 6.1 E2E Tests
**File**: `tests/e2e/workflow-dependencies.spec.ts` (NEW)

**Test Scenarios**:
1. Create template with parallel steps (no dependencies)
2. Create template with sequential dependencies (A â†’ B â†’ C)
3. Create template with fork/join pattern (A â†’ B,C â†’ D)
4. Create template with ALL dependency logic
5. Create template with ANY dependency logic
6. Reject template with circular dependencies
7. Execute workflow with parallel steps
8. Execute workflow with sequential dependencies
9. Verify dependent step transitions to READY

**Target**: 9 passing tests

#### 6.2 User Guide
**File**: `docs/features/workflow/P0.2-DEPENDENCIES-GUIDE.md` (NEW)

**Sections**:
1. Introduction to Flexible Dependencies
2. Use Cases (parallel tasks, fork/join, complex graphs)
3. Dependency Logic (ALL vs ANY)
4. Creating Dependencies in Template Editor
5. How Dependencies Affect Execution
6. Best Practices
7. Troubleshooting (cycles, blocked steps)
8. Examples (common patterns)

**Target**: 500+ lines

#### 6.3 Technical Documentation
**File**: `docs/MASTER-SYSTEM-DOCUMENTATION.md`

**Updates**:
- Section 6.6: Flexible Step Dependencies
- Architecture diagram with dependency graph
- API reference for dependency endpoints
- Schema documentation for new fields

**Target**: 300+ lines of additions

#### 6.4 Test Report
**File**: `docs/features/workflow/P0.2-TEST-REPORT.md` (NEW)

**Contents**:
- Test execution summary
- Unit test results (21+ tests)
- API test results (5+ tests)
- E2E test results (9+ tests)
- Issues discovered and fixed
- Production readiness assessment

**Deliverables**:
- [x] E2E tests (9+ passing)
- [x] User guide (500+ lines)
- [x] Technical documentation (300+ lines)
- [x] Test report

**Time Estimate**: 4-5 hours

---

## Implementation Timeline

### Day 1 (8 hours)
- **Morning** (4h): Phase 1 + Phase 2
  - Update schema and create migration
  - Implement dependency resolver
  - Write unit tests for resolver
- **Afternoon** (4h): Phase 3
  - Integrate into runtime
  - Update step state transitions
  - Write runtime unit tests

### Day 2 (8 hours)
- **Morning** (4h): Phase 4
  - Update Zod schemas
  - Create validation endpoint
  - Update template APIs
  - Write API tests
- **Afternoon** (4h): Phase 5 (Part 1)
  - Create DependencySelector component
  - Create DependencyBadge component
  - Start template editor integration

### Day 3 (6 hours)
- **Morning** (3h): Phase 5 (Part 2)
  - Complete template editor integration
  - Create DependencyVisualization component
  - Update instance step display
- **Afternoon** (3h): Phase 6
  - Write E2E tests
  - Create user guide
  - Update technical docs
  - Create test report

**Total**: ~22 hours (2.5 days)

---

## Success Criteria

### Code Quality
- [ ] All unit tests passing (21+ tests)
- [ ] All API tests passing (5+ tests)
- [ ] All E2E tests passing (9+ tests)
- [ ] No TypeScript errors
- [ ] ESLint passing
- [ ] Prisma client regenerated

### Functionality
- [ ] Can create templates with dependencies
- [ ] Can specify ALL/ANY dependency logic
- [ ] Circular dependencies are rejected
- [ ] Step state updates correctly based on dependencies
- [ ] Parallel steps execute simultaneously
- [ ] Sequential dependencies enforce order
- [ ] UI shows dependency status clearly

### Documentation
- [ ] User guide complete (500+ lines)
- [ ] Technical docs updated (300+ lines)
- [ ] Test report created
- [ ] Code comments for complex logic
- [ ] API endpoints documented

---

## Risks & Mitigations

### Risk 1: Complex Dependency Graphs Hard to Visualize
**Mitigation**: 
- Start with simple list-based UI
- Add graph visualization in Phase 5
- Use color coding for clarity

### Risk 2: Performance with Many Dependencies
**Mitigation**:
- Efficient cycle detection algorithm (DFS)
- Cache dependency calculation results
- Index on `dependsOn` field

### Risk 3: UI Confusion for End Users
**Mitigation**:
- Clear labels and tooltips
- Visual examples in user guide
- Validation errors with helpful messages
- Default to no dependencies (backwards compatible)

### Risk 4: Breaking Changes to Existing Workflows
**Mitigation**:
- Default `dependsOn` to empty array (no dependencies)
- Existing workflows continue to work as before
- Order-based execution still works (no dependencies = sequential)

---

## Next Steps

1. **Phase 1**: Start with schema changes
2. **Validate**: Review schema with team
3. **Proceed**: Continue with implementation phases
4. **Review**: Daily check-ins on progress
5. **Test**: Comprehensive testing before marking complete
6. **Deploy**: Ready for production after all tests pass

---

**Status**: ðŸŸ¡ **READY TO START**  
**Next Action**: Begin Phase 1 - Schema & Database

**Created by**: GitHub Copilot  
**Date**: October 19, 2025
